#!/usr/bin/env python

PACKAGE = "bachelors_final_project"

import math
from dynamic_reconfigure.parameter_generator_catkin import *

gen = ParameterGenerator()

##################################### Cropping #################################
cropping = gen.add_group("Cropping", type="collapse", state=False)
cropping.add("scaleParam", double_t, 0,
        "The red one.",
        3.0, 0.0, 10.0)
cropping.add("xTranslateParam", int_t, 0,
        "The green one.",
        7, -128, 128)
cropping.add("yTranslateParam", int_t, 0,
        "The Blue one.",
        -10, -196, 196)

############################### Gaussian Smoothing ############################
gaussianSmoothing = gen.add_group("Gaussian Smoothing", type="hide", state=False)
gaussianSmoothing.add("gaussianSigmaParam", double_t, 0,
        "The Gaussian sigma.",
        2.0, 0.000001, 10000)
gaussianSmoothing.add("gaussianSearchRadiusParam", double_t, 0,
        "The Gaussian search radius.",
        0.005, 0.000001, 0.025)

############################ Compute normals efficiently ##############################
computeNormalsEfficiently = gen.add_group("Compute normals efficiently", type="collapse", state=False)
size_enum = gen.enum([ gen.const("COVARIANCE_MATRIX",      int_t, 1, "A small constant"),
                     gen.const("AVERAGE_3D_GRADIENT",     int_t, 2, "A medium constant"),
                     gen.const("AVERAGE_DEPTH_CHANGE",      int_t, 3, "A large constant"),
                     gen.const("SIMPLE_3D_GRADIENT", int_t, 4, "An extra large constant")],
                     "Selector of the normals estimation method enum.")
computeNormalsEfficiently.add("normalEstimationMethodParam", int_t, 0,
        "Selector of the normals estimation method.",
        1, 1, 4, edit_method=size_enum)
computeNormalsEfficiently.add("maxDepthChangeFactorParam", double_t, 0,
        "The depth change threshold for computing object borders in integral normal estimation. ",
        0.42, 0, 1)
computeNormalsEfficiently.add("useDepthDependentSmoothingParam", bool_t, 0,
        "Set if using depth dependent smoothing",
        True)
computeNormalsEfficiently.add("normalSmoothingSizeParam", double_t, 0,
        "Factor which influences the size of the area used to smooth normals",
        15.0, 0)

################################# Fit Plane From Normals ################################
fitPlaneFromNormals = gen.add_group("Fit Plane From Normals", type="collapse", state=False)
fitPlaneFromNormals.add("normalDistanceWeightParam", double_t, 0,
        "Set the relative weight (between 0 and 1) to give to the angular distance",
        0.2, 0, 1)
fitPlaneFromNormals.add("originDistanceParam", double_t, 0,
        "Set the relative weight (between 0 and 1) to give to the angular distance",
        1.5, 0, 10)
fitPlaneFromNormals.add("maxIterationsParam", int_t, 0,
        "Set the relative weight (between 0 and 1) to give to the angular distance",
        250, 10, 5000)
fitPlaneFromNormals.add("distanceThresholdParam", double_t, 0,
        "Points within this distance from the hypothesized plane are scored as inliers",
        0.15, 0, 10)
fitPlaneFromNormals.add("optimizeCoefficientsParam", bool_t, 0,
        "Points within this distance from the hypothesized plane are scored as inliers",
        True)
fitPlaneFromNormals.add("probabilityParam", double_t, 0,
        "Points within this distance from the hypothesized plane are scored as inliers",
        0.5, 0.0001, 1.0)
fitPlaneFromNormals.add("sampleMaxDistanceParam", double_t, 0,
        "Points within this distance from the hypothesized plane are scored as inliers",
        0.05, 0, 10)
fitPlaneFromNormals.add("useSpecificPlaneParam", bool_t, 0,
        "Points within this distance from the hypothesized plane are scored as inliers",
        False)
fitPlaneFromNormals.add("planeXParam", double_t, 0,
        "Points within this distance from the hypothesized plane are scored as inliers",
        0, -1, 1)
fitPlaneFromNormals.add("planeYParam", double_t, 0,
        "Points within this distance from the hypothesized plane are scored as inliers",
        1, -1, 1)
fitPlaneFromNormals.add("planeZParam", double_t, 0,
        "Points within this distance from the hypothesized plane are scored as inliers",
        0, -1, 1)
fitPlaneFromNormals.add("epsAngleParam", double_t, 0,
        "Points within this distance from the hypothesized plane are scored as inliers",
        2*math.pi, 0, 2*math.pi)

############################ Extract Cloud Over The Table ############################
cloudOverTable = gen.add_group("Cloud Over The Table", type="collapse", state=False)
cloudOverTable.add("minHeightParam", double_t, 0,
        "Min prism height",
        0.01, 0.0, 1.0)
cloudOverTable.add("maxHeightParam", double_t, 0,
        "Max prism height",
        0.05, 0.0, 1.0)

############################ Euclidean Cluster Extraction ############################
clustering = gen.add_group("Euclidean Cluster Extraction", type="collapse")
clustering.add("clusterTolerance", double_t, 0,
        "Min prism height",
        0.03, 0.0, 1.0)
clustering.add("minClusterSize", int_t, 0,
        "Max prism height",
        100, 50, 1000)
clustering.add("maxClusterSize", int_t, 0,
        "Max prism height",
        2000, 1001, 20000)

########################################## Visualizer ################################
gen.add("normalsCountParam", int_t, 0,
        "Show normals every normalsCount levels.",
        200, 1,1000)
gen.add("normalsSizeParam", double_t, 0,
        "Changes normals size.",
        0.02, 0.001,10)

################################## Reset everything ##################################
gen.add("defaultParams", bool_t, 0,
        "Return values to default",
        False)        

exit(gen.generate(PACKAGE, PACKAGE, "Parameters"))
